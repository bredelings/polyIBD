frwrd_sum <- frwrd_mat[z,0] + frwrd_mat[z,0]
}
frwrd_mat
############################
### forward algorithm ######
############################
emm <- 1 # trick
trans_table <- transmatrixbyhand
#   // carry out first step of algorithm
#  frwrd_mat = vector< vector<double> >(m_max+1, vector<double>(L));
frwrd_mat <- matrix(0, z_max+1, L+1)
for(z in 1:(z_max+1)){
frwrd_mat[z,1] <- dbinom(z,z_max,f,FALSE)*emm
frwrd_sum <- frwrd_mat[z,1] + frwrd_mat[z,1]
}
frwrd_mat
logLike <- 0 #init
logLike = logLike + log(frwrd_sum)
for(z in 1:(z_max+1)){
frwrd_mat[z,1] <- frwrd_mat[z,1]/frwrd_sum
}
frwrd_mat
############################
### forward algorithm ######
############################
emm <- 1 # trick
trans_table <- transmatrixbyhand
trans_table <- transition_lookup[[1]]
dbinom(z,z_max,f,FALSE)
dbinom(z,z_max,f,FALSE)
dbinom(z,z_max,f,FALSE)
dbinom(z,z_max,f,FALSE)
z
# generate rate matrix
z0 <- z_max
z1 <- z_max+1
#----------- play
rateMat <- matrix(letters[1:12], z1, z1)
rateMat[cbind(1:z0, 1:z0 + 1)]
rateMat[cbind(1:z0 + 1, 1:z0)]
rateMat[cbind(1:z1, 1:z1)]
rateMat
#-------------- start
rateMat <- matrix(0, z1, z1)
rateMat[cbind(1:z0, 1:z0 + 1)] <- (z0:1)*rho*k*(1-f) # this is the poisson process assuming constant rates
rateMat[cbind(1:z0 + 1, 1:z0)] <- (z0:1)*rho*k*f # this is the poisson process assuming constant rates
rateMat[cbind(1:z1, 1:z1)] <- -rowSums(rateMat) # Rates are symmetrical, so negative flow here (this replaces the 1-p, if this were a probability matrix)
rateMat
# obtain Eigen values and vectors
E <- eigen(t(rateMat))
Evalues=E$values
Evectors=E$vectors
Esolve <- solve(E$vectors)
transition_lookup <- lapply(1, function(x){matrix(0, z_max+1, z_max+1)}) # cheat for now since L-1 is 0
### bob's cpp code, script MCMC.cpp, function update_transition_lookup -- line 387
for(j in 1:(L-1)){
if(j!=0){ # silly escape for fact I only want to look at one SNP distance
for(z1 in 1:(z_max+1)){
for(z2 in 1:(z_max+1)){
for(i in 1:(z_max+1)){
# i'm ignoing the chromosome jump over contigs trick
transition_lookup[[j]][z1,z2] <- transition_lookup[[j]][z1,z2] + Evectors[z2,i] * Esolve[i,z1] * exp(Evalues[i]*SNP_dist[j])
}}
}
}
}
transition_lookup
transmatrixbyhand <- matrix(NA,2,2)
transmatrixbyhand[2,2] <- 1 - (1-f)*(1-exp(-k*rho*d)) #t22
transmatrixbyhand[1,2] <- (1-f)*(1-exp(-k*rho*d)) #t12
transmatrixbyhand[2,1] <- f*(1-exp(-k*rho*d)) #21
transmatrixbyhand[1,1] <- 1 - f*(1-exp(-k*rho*d)) #t11
transmatrixbyhand
z_max
for(z in 1:(z_max+1)){
frwrd_mat[z,1] <- dbinom(z,(z_max+1),f,FALSE)*emm
frwrd_sum <- frwrd_mat[z,1] + frwrd_mat[z,1]
}
frwrd_sum
frwrd_mat
logLike <- 0 #init
logLike = logLike + log(frwrd_sum)
for(z in 1:(z_max+1)){
frwrd_mat[z,1] <- frwrd_mat[z,1]/frwrd_sum
}
frwrd_mat
#   // carry out first step of algorithm
#  frwrd_mat = vector< vector<double> >(m_max+1, vector<double>(L));
frwrd_mat <- matrix(0, z_max+1, L+1)
for(z in 1:(z_max+1)){
frwrd_mat[z,1] <- dbinom(z,(z_max+1),f,FALSE)*emm
frwrd_sum <- frwrd_mat[z,1] + frwrd_mat[z,1]
}
logLike <- 0 #init
logLike = logLike + log(frwrd_sum)
for(z in 1:(z_max+1)){
frwrd_mat[z,1] <- frwrd_mat[z,1]/frwrd_sum
}
for(j in 1:L){
frwrd_sum <- 0
for(z in 1:(z_max+1)){
for(i in 1:(z_max+1)){
frwrd_mat[z,j] <- frwrd_mat[z,j] + frwrd_mat[i, (j-1)] * trans_table[i,z]; # no j-1 here because only 1 loci
}
frwrd_mat[z,j] * emm
frwrd_sum <- frwrd_mat[z,j] + frwrd_mat[z,j]
}
logLike <- logLike + log(frwrd_sum)
for(z in 1:(z_max+1)){
frwrd_mat[z,j] <- frwrd_mat[z,j]/frwrd_sum
}
}
for(j in 2:L){
frwrd_sum <- 0
for(z in 1:(z_max+1)){
for(i in 1:(z_max+1)){
frwrd_mat[z,j] <- frwrd_mat[z,j] + frwrd_mat[i, (j-1)] * trans_table[i,z]; # no j-1 here because only 1 loci
}
frwrd_mat[z,j] * emm
frwrd_sum <- frwrd_mat[z,j] + frwrd_mat[z,j]
}
logLike <- logLike + log(frwrd_sum)
for(z in 1:(z_max+1)){
frwrd_mat[z,j] <- frwrd_mat[z,j]/frwrd_sum
}
}
frwrd_mat
setwd("~/Documents/GitHub/polyIBD/")
library(polyIBD)
# load bobFunctions package. If not already installed, this can be obtained from github via the devtools command install_github('bobverity/bobFunctions')
library(bobFunctions)
#library(devtools)
#devtools::install_github("nickbrazeau/polyIBD", ref = "devo_branch5")
#library(polyIBD)
# ------------------------------------------------------------------
# background data
pfgencoord <- read.csv(file="~/Desktop/pf_genetic_coords.csv", header = T)
summary(pfgencoord)
mean(pfgencoord$length)
# simulate data
n <- 1e3
rho_true <- 7.4e-7
f_true <- 0.4
m1 <- 3
m2 <- 3
m_true <- c(m1,m2)
pos <- sort(sample(1.4e6, n))
k_true <- 2
#set.seed(3)
sim <- simData(pos=list(contig1=pos),
m1=m_true[1], m2=m_true[2],
f=f_true, rho=rho_true, k=k_true, p=NULL, p_shape1=0.1, p_shape2=0.1)
trueIBD <- data.frame(CHROM = sim$IBD$CHROM, POS=sim$IBD$POS,
z_true =rowSums(sim$IBD[3:ncol(sim$IBD)]))
ggplot() + geom_line(data=trueIBD, aes(x=POS, y=z_true)) + facet_grid(~CHROM)
library(tidyverse)
# run MCMC
ret <- polyIBD::runMCMC(vcf=sim$vcf, p=sim$p, rho=rho_true, k_max=50,
burnin=5e3, samples=1e4, reportIteration=1e2)
ret
polyIBD::ggplot_IBDraster(ret, trueIBD = trueIBD,
truem1 = m_true[1], truem2 = m_true[2],
truef = f_true, truek = k_true)
transition_lookup
transmatrixbyhand[2,2]
transmatrixbyhand[1,2]
############################
### forward algorithm ######
############################
emm <- 1 # trick
trans_table <- transmatrixbyhand
trans_table <- transition_lookup[[1]]
#   // carry out first step of algorithm
#  frwrd_mat = vector< vector<double> >(m_max+1, vector<double>(L));
frwrd_mat <- matrix(0, z_max+1, L+1)
for(z in 1:(z_max+1)){
frwrd_mat[z,1] <- dbinom(z,(z_max+1),f,FALSE)*emm
frwrd_sum <- frwrd_mat[z,1] + frwrd_mat[z,1]
}
frwrd_mat
logLike <- 0 #init
logLike = logLike + log(frwrd_sum)
for(z in 1:(z_max+1)){
frwrd_mat[z,1] <- frwrd_mat[z,1]/frwrd_sum
}
frwrd_mat
for(j in 2:L){
frwrd_sum <- 0
for(z in 1:(z_max+1)){
for(i in 1:(z_max+1)){
frwrd_mat[z,j] <- frwrd_mat[z,j] + frwrd_mat[i, (j-1)] * trans_table[i,z]; # no j-1 here because only 1 loci
print(frwrd_mat)
}
frwrd_mat[z,j] * emm
frwrd_sum <- frwrd_mat[z,j] + frwrd_mat[z,j]
}
logLike <- logLike + log(frwrd_sum)
for(z in 1:(z_max+1)){
frwrd_mat[z,j] <- frwrd_mat[z,j]/frwrd_sum
}
}
## for model
f = 0.6
rho =1e-7 # in malaria it is 7.4e-7, close enough
k = 1 # keep k low because if k goes very high it is just independent loci
d = 3e7 # this sets up at least one recombination event
n = 1 # just pretend we have one SNP here...this shouldn't matter for just one solve of eigens
## FOR cpp code
z_max = 1
L <- n # number of loci, this is stored in MCMC class
SNP_dist=d # only works because one snp dist
# generate rate matrix
z0 <- z_max
z1 <- z_max+1
#----------- play
rateMat <- matrix(letters[1:12], z1, z1)
rateMat[cbind(1:z0, 1:z0 + 1)]
rateMat[cbind(1:z0 + 1, 1:z0)]
rateMat[cbind(1:z1, 1:z1)]
rateMat
#-------------- start
rateMat <- matrix(0, z1, z1)
rateMat[cbind(1:z0, 1:z0 + 1)] <- (z0:1)*rho*k*(1-f) # this is the poisson process assuming constant rates
rateMat[cbind(1:z0 + 1, 1:z0)] <- (z0:1)*rho*k*f # this is the poisson process assuming constant rates
rateMat[cbind(1:z1, 1:z1)] <- -rowSums(rateMat) # Rates are symmetrical, so negative flow here (this replaces the 1-p, if this were a probability matrix)
rateMat
# obtain Eigen values and vectors
E <- eigen(t(rateMat))
Evalues=E$values
Evectors=E$vectors
Esolve <- solve(E$vectors)
transition_lookup <- lapply(1, function(x){matrix(0, z_max+1, z_max+1)}) # cheat for now since L-1 is 0
transition_lookup <- lapply(1, function(x){matrix(0, z_max+1, z_max+1)}) # cheat for now since L-1 is 0
### bob's cpp code, script MCMC.cpp, function update_transition_lookup -- line 387
for(j in 1:(L-1)){
if(j!=0){ # silly escape for fact I only want to look at one SNP distance
for(z1 in (z_max+1):1){
for(z2 in (z_max+1):1){
for(i in 1:(z_max+1)){
# i'm ignoing the chromosome jump over contigs trick
transition_lookup[[j]][z1,z2] <- transition_lookup[[j]][z1,z2] + Evectors[z2,i] * Esolve[i,z1] * exp(Evalues[i]*SNP_dist[j])
}}
}
}
}
transition_lookup
transmatrixbyhand <- matrix(NA,2,2)
transmatrixbyhand[2,2] <- 1 - (1-f)*(1-exp(-k*rho*d)) #II
transmatrixbyhand[1,2] <- (1-f)*(1-exp(-k*rho*d)) #IU
transmatrixbyhand[2,1] <- f*(1-exp(-k*rho*d)) #UI
transmatrixbyhand[1,1] <- 1 - f*(1-exp(-k*rho*d)) #tUU
transmatrixbyhand
transition_lookup <- lapply(1, function(x){matrix(0, z_max+1, z_max+1)}) # cheat for now since L-1 is 0
transition_lookup
### bob's cpp code, script MCMC.cpp, function update_transition_lookup -- line 387
for(j in 1:(L-1)){
if(j!=0){ # silly escape for fact I only want to look at one SNP distance
for(z1 in (z_max+1):1){
print(z_max)
for(z2 in (z_max+1):1){
for(i in 1:(z_max+1)){
# i'm ignoing the chromosome jump over contigs trick
transition_lookup[[j]][z1,z2] <- transition_lookup[[j]][z1,z2] + Evectors[z2,i] * Esolve[i,z1] * exp(Evalues[i]*SNP_dist[j])
}}
}
}
}
z_max
### bob's cpp code, script MCMC.cpp, function update_transition_lookup -- line 387
for(j in 1:(L-1)){
if(j!=0){ # silly escape for fact I only want to look at one SNP distance
for(z1 in (z_max+1):1){
paste("z1", z1)
for(z2 in (z_max+1):1){
paste("z1", z2)
for(i in 1:(z_max+1)){
# i'm ignoing the chromosome jump over contigs trick
transition_lookup[[j]][z1,z2] <- transition_lookup[[j]][z1,z2] + Evectors[z2,i] * Esolve[i,z1] * exp(Evalues[i]*SNP_dist[j])
}}
}
}
}
### bob's cpp code, script MCMC.cpp, function update_transition_lookup -- line 387
for(j in 1:(L-1)){
if(j!=0){ # silly escape for fact I only want to look at one SNP distance
for(z1 in (z_max+1):1){
cat(paste("z1", z1))
for(z2 in (z_max+1):1){
cat(paste("z2", z2))
for(i in 1:(z_max+1)){
# i'm ignoing the chromosome jump over contigs trick
transition_lookup[[j]][z1,z2] <- transition_lookup[[j]][z1,z2] + Evectors[z2,i] * Esolve[i,z1] * exp(Evalues[i]*SNP_dist[j])
}}
}
}
}
### bob's cpp code, script MCMC.cpp, function update_transition_lookup -- line 387
for(j in 1:(L-1)){
if(j!=0){ # silly escape for fact I only want to look at one SNP distance
for(z1 in (z_max+1):1){
cat(paste("z1", z1, "\n"))
for(z2 in (z_max+1):1){
cat(paste("z2", z2, "\n"))
for(i in 1:(z_max+1)){
# i'm ignoing the chromosome jump over contigs trick
transition_lookup[[j]][z1,z2] <- transition_lookup[[j]][z1,z2] + Evectors[z2,i] * Esolve[i,z1] * exp(Evalues[i]*SNP_dist[j])
}}
}
}
}
### bob's cpp code, script MCMC.cpp, function update_transition_lookup -- line 387
for(j in 1:(L-1)){
if(j!=0){ # silly escape for fact I only want to look at one SNP distance
for(z1 in (z_max+1):1){
cat(paste("z1", z1, "\n"))
for(z2 in (z_max+1):1){
cat(paste("z2", z2, "\n"))
for(i in 1:(z_max+1)){
# i'm ignoing the chromosome jump over contigs trick
transition_lookup[[j]][z1,z2] <- transition_lookup[[j]][z1,z2] + Evectors[z2,i] * Esolve[i,z1] * exp(Evalues[i]*SNP_dist[j])
}}
}
}
}
transition_lookup
transition_lookup <- lapply(1, function(x){matrix(0, z_max+1, z_max+1)}) # cheat for now since L-1 is 0
### bob's cpp code, script MCMC.cpp, function update_transition_lookup -- line 387
for(j in 1:(L-1)){
if(j!=0){ # silly escape for fact I only want to look at one SNP distance
for(z1 in (z_max+1):1){
cat(paste("z1", z1, "\n"))
for(z2 in (z_max+1):1){
cat(paste("z2", z2, "\n"))
for(i in 1:(z_max+1)){
# i'm ignoing the chromosome jump over contigs trick
transition_lookup[[j]][z1,z2] <- transition_lookup[[j]][z1,z2] + Evectors[z2,i] * Esolve[i,z1] * exp(Evalues[i]*SNP_dist[j])
}}
}
}
}
transition_lookup
transition_lookup <- lapply(1, function(x){matrix(0, z_max+1, z_max+1)}) # cheat for now since L-1 is 0
### bob's cpp code, script MCMC.cpp, function update_transition_lookup -- line 387
for(j in 1:(L-1)){
if(j!=0){ # silly escape for fact I only want to look at one SNP distance
for(z1 in 1:(z_max+1)){
cat(paste("z1", z1, "\n"))
for(z2 in 1:(z_max+1)){
cat(paste("z2", z2, "\n"))
for(i in 1:(z_max+1)){
# i'm ignoing the chromosome jump over contigs trick
transition_lookup[[j]][z1,z2] <- transition_lookup[[j]][z1,z2] + Evectors[z2,i] * Esolve[i,z1] * exp(Evalues[i]*SNP_dist[j])
}}
}
}
}
transition_lookup
rotate <- function(x) t(apply(x, 2, rev))
#----------- play
rateMat <- matrix(letters[1:12], z1, z1)
rateMat[cbind(1:z0, 1:z0 + 1)]
rateMat[cbind(1:z0 + 1, 1:z0)]
rateMat[cbind(1:z1, 1:z1)]
rateMat
rotate(rateMat)
library(polyIBD)
# simulate data
n <- 1e3
rho_true <- 7.4e-7
f_true <- 0.4
m1 <- 3
m2 <- 3
m_true <- c(m1,m2)
pos <- sort(sample(1.4e6, n))
k_true <- 2
#set.seed(3)
sim <- simData(pos=list(contig1=pos),
m1=m_true[1], m2=m_true[2],
f=f_true, rho=rho_true, k=k_true, p=NULL, p_shape1=0.1, p_shape2=0.1)
trueIBD <- data.frame(CHROM = sim$IBD$CHROM, POS=sim$IBD$POS,
z_true =rowSums(sim$IBD[3:ncol(sim$IBD)]))
ggplot() + geom_line(data=trueIBD, aes(x=POS, y=z_true)) + facet_grid(~CHROM)
# run MCMC
ret <- polyIBD::runMCMC(vcf=sim$vcf, p=sim$p, rho=rho_true, k_max=50,
burnin=5e3, samples=1e4, reportIteration=1e2)
vcffile="~/Desktop/polyIBD_Temp/play3.vcf"
input = polyIBD::vcf2polyIBDinput(vcffile = vcffile)
input$vcf
input$snpmatrixlist[[1]]
vcf=input$snpmatrixlist[[1]]
# extract basic parameters
tab1 <- table(vcf[,1]) # first column in this class is CHROM
nc <- length(tab1)
cnames <- names(tab1)
n <- as.vector(tab1)
cnames
# get distances between SNPs. Distance=-1 between contigs, indicating infinite distance
SNP_dist <- diff(vcf[,2]) # second column in this class is POS
SNP_dist[cumsum(n)[1:(nc-1)]] <- -1
SNP_dist
# compare two samples and save comparison type in vector x
# x is an integer vector with values in 0:15. These values indicate genotype combinations that cycle through the four options: {missing, homo REF, het, homo ALT} in the first sample, then the same four options in the second sample, leading to 16 options in total
x <- 4*(vcf[,3]+1) + (vcf[,4]+1)
vcf[,3]
# -----------------------------------------------------
# Read and check input
#------------------------------------------------------
if(is.null(vcffile)){
if(class(vcfR) != "vcfR"){
stop("vcfR object must be of class vcfR")
}
vcf <- vcfR
} else{
vcf <- vcfR::read.vcfR(file=vcffile, verbose=T) # read vcf
}
# -----------------------------------------------------
# determine ploidy to determine genotype numeric placeholder
#------------------------------------------------------
ploidy <- stringr::str_extract(vcf@meta[grepl("ploidy", vcf@meta)], "ploidy=[0-9]")
ploidy <- stringr::str_split(t(ploidy), "=", simplify = T)
ploidy <- as.numeric(ploidy[1,2])
if(ploidy == 2){
snpmatrix <- vcfR::extract.gt(vcf, element='GT', as.numeric=F)
snpmatrix[snpmatrix == "0/0"] <- 0
snpmatrix[snpmatrix == "0/1"] <- 1
snpmatrix[snpmatrix == "1/1"] <- 2
} else if(ploidy == 1){
snpmatrix <- vcfR::extract.gt(vcf, element='GT', as.numeric=F)
snpmatrix[snpmatrix == "0"] <- 0
snpmatrix[snpmatrix == "1"] <- 2
} else {
stop("You have a ploidy that is less than 1 or greater than 3, which cannot be accomodated by polyIBD")
}
# -----------------------------------------------------
# Determine the number of samples and thier combinations
#------------------------------------------------------
smpls <- factor(colnames(vcfR::extract.gt(vcf)))
smpls <- t(combn(smpls, 2))
snpmatrixlist <- lapply(1:nrow(smpls), function(x){matrix(NA, ncol=4, nrow=nrow(snpmatrix))})
CHROM <- vcfR::getCHROM(vcf)
POS <- vcfR::getPOS(vcf)
for(i in 1:nrow(smpls)){
snpmatrixsave <- snpmatrix[, colnames(snpmatrix) %in% smpls[i,]]
snpmatrixsave <- cbind.data.frame(CHROM, POS, snpmatrixsave)
snpmatrixlist[[i]] <- snpmatrixsave
}
snpmatrixlist
str(snpmatrixlist[[1]])
# -----------------------------------------------------
# determine ploidy to determine genotype numeric placeholder
#------------------------------------------------------
ploidy <- stringr::str_extract(vcf@meta[grepl("ploidy", vcf@meta)], "ploidy=[0-9]")
ploidy <- stringr::str_split(t(ploidy), "=", simplify = T)
ploidy <- as.numeric(ploidy[1,2])
if(ploidy == 2){
snpmatrix <- vcfR::extract.gt(vcf, element='GT', as.numeric=F)
snpmatrix[snpmatrix == "0/0"] <- 0
snpmatrix[snpmatrix == "0/1"] <- 1
snpmatrix[snpmatrix == "1/1"] <- 2
} else if(ploidy == 1){
snpmatrix <- vcfR::extract.gt(vcf, element='GT', as.numeric=F)
snpmatrix[snpmatrix == "0"] <- 0
snpmatrix[snpmatrix == "1"] <- 2
} else {
stop("You have a ploidy that is less than 1 or greater than 3, which cannot be accomodated by polyIBD")
}
str(snpmatrix)
snpmatrix <- vcfR::extract.gt(vcf, element='GT', as.numeric=F)
str(snpmatrix)
snpmatrix
snpmatrix <- vcfR::extract.gt(vcf, element='GT', as.numeric=F)
snpmatrix[snpmatrix == "0/0"] <- 0
snpmatrix[snpmatrix == "0/1"] <- 1
snpmatrix[snpmatrix == "1/1"] <- 2
snpmatrix
snpmatrix[snpmatrix == "0/0"] <- as.numeric(0)
snpmatrix
snpmatrix[snpmatrix == "0/0"] <- 0
snpmatrix[snpmatrix == "0/1"] <- 1
snpmatrix[snpmatrix == "1/1"] <- 2
snpmatrix <- apply(snpmatrix, 1, function(x){as.numeric(x)})
snpmatrix
snpmatrix <- vcfR::extract.gt(vcf, element='GT', as.numeric=F)
snpmatrix[snpmatrix == "0/0"] <- 0
snpmatrix[snpmatrix == "0/1"] <- 1
snpmatrix[snpmatrix == "1/1"] <- 2
snpmatrix <- apply(snpmatrix, 2, function(x){as.numeric(x)})
snpmatrix
snpmatrix <- vcfR::extract.gt(vcf, element='GT', as.numeric=F)
snpmatrix
snpmatrix <- vcfR::extract.gt(vcf, element='GT', as.numeric=T)
snpmatrix
snpmatrix <- vcfR::extract.gt(vcf, element='GT', as.numeric=F) # numeric as T doesn't parse 0/1 correctly
snpmatrix[snpmatrix == "0/0"] <- 0
snpmatrix[snpmatrix == "0/1"] <- 1
snpmatrix[snpmatrix == "1/1"] <- 2
snpmatrix
snpmatrix <- vcfR::extract.gt(vcf, element='GT', as.numeric=F) # numeric as T doesn't parse 0/1 correctly
snpmatrix
snpmatrix[snpmatrix=="0/1"]
which(snpmatrix[snpmatrix=="0/1"])
which(snpmatrix=="0/1")
snpmatrix <- vcfR::extract.gt(vcf, element='GT', as.numeric=T) # numeric as T doesn't parse 0/1 correctly
snpmatrix[174]
snpmatrix <- vcfR::extract.gt(vcf, element='GT', as.numeric=F) # numeric as T doesn't parse 0/1 correctly
snpmatrix[snpmatrix == "0/0"] <- 0
snpmatrix[snpmatrix == "0/1"] <- 1
snpmatrix[snpmatrix == "1/1"] <- 2
snpmatrix <- apply(snpmatrix, 2, function(x){as.numeric(x)}) # need to convert from char (--dependent on case of "/") to numeric
snpmatrix <- vcfR::extract.gt(vcf, element='GT', as.numeric=T)
snpmatrix
setwd("~/Documents/GitHub/polyIBD/")
